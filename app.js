
const stems = ["갑","을","병","정","무","기","경","신","임","계"];
const branches = ["자","축","인","묘","진","사","오","미","신","유","술","해"];
const stemElem = {"갑":"목","을":"목","병":"화","정":"화","무":"토","기":"토","경":"금","신":"금","임":"수","계":"수"};
const branchElem = {"자":"수","축":"토","인":"목","묘":"목","진":"토","사":"화","오":"화","미":"토","신":"금","유":"금","술":"토","해":"수"};

function toJulianDay(y,m,d){ const a=Math.floor((14-m)/12); const y2=y+4800-a; const m2=m+12*a-3; return d + Math.floor((153*m2+2)/5) + 365*y2 + Math.floor(y2/4) - Math.floor(y2/100) + Math.floor(y2/400) - 32045; }
function dateFromJD(jd){ const Z=Math.floor(jd+0.5); const F=(jd+0.5)-Z; let A=Z; if(Z>=2299161){ const alpha=Math.floor((Z-1867216.25)/36524.25); A=Z+1+alpha-Math.floor(alpha/4);} const B=A+1524; const C=Math.floor((B-122.1)/365.25); const D=Math.floor(365.25*C); const E=Math.floor((B-D)/30.6001); const day=B-D-Math.floor(30.6001*E)+F; const month=(E<14)?(E-1):(E-13); const year=(month>2)?(C-4716):(C-4715); const dayInt=Math.floor(day); let frac=day-dayInt; const hours=Math.floor(frac*24); frac=frac*24-hours; const minutes=Math.floor(frac*60); frac=frac*60-minutes; const seconds=Math.floor(frac*60); const ms=Math.round((frac*60-seconds)*1000); return new Date(Date.UTC(year, month-1, dayInt, hours, minutes, seconds, ms)); }
function sunEclipticLongitude(jd){ const T=(jd-2451545.0)/36525.0; const L0=(280.46646+36000.76983*T+0.0003032*T*T)%360; const M=(357.52911+35999.05029*T-0.0001537*T*T)*Math.PI/180; const C=(1.914602-0.004817*T-0.000014*T*T)*Math.sin(M)+(0.019993-0.000101*T)*Math.sin(2*M)+0.000289*Math.sin(3*M); let lam=L0+C; const Omega=(125.04-1934.136*T)*Math.PI/180; lam=lam-0.00569-0.00478*Math.sin(Omega)*180/Math.PI; lam=(lam%360+360)%360; return lam; }
function termLongitudeDeg(idx){ return (285 + 15*idx) % 360; }
function findTermTimeJD(yearUTC, idx){ const approxDaysFromJan=idx*15.2184; const jdJan1=toJulianDay(yearUTC,1,1)-0.5; let lo=jdJan1+approxDaysFromJan-10; let hi=jdJan1+approxDaysFromJan+10; const target=termLongitudeDeg(idx); function delta(lon){ let d=lon-target; d=((d+180)%360+360)%360-180; return d;} for(let k=0;k<60;k++){ const mid=(lo+hi)/2; const dmid=delta(sunEclipticLongitude(mid)); const dlo=delta(sunEclipticLongitude(lo)); if(Math.abs(hi-lo)<1e-6) return mid; if((dlo<0&&dmid>0)||(dlo>0&&dmid<0)) hi=mid; else lo=mid;} return (lo+hi)/2; }
function solarTermsLocal(yearUTC, tzHours){ const list=[]; for(let i=0;i<24;i++){ const jd=findTermTimeJD(yearUTC,i); const utc=dateFromJD(jd); list.push(new Date(utc.getTime()+tzHours*3600*1000)); } return list; }

function yearPillar(local, tzHours){ const yUTC=local.getUTCFullYear(); const lichun=solarTermsLocal(yUTC,tzHours)[2]; const base=(local>=lichun)?yUTC:(yUTC-1); const s=stems[((base-1984)%10+10)%10]; const z=branches[((base-1984)%12+12)%12]; return [s,z]; }
function monthPillar(local, tzHours){ const yUTC=local.getUTCFullYear(); const tThis=solarTermsLocal(yUTC,tzHours); const tNext=solarTermsLocal(yUTC+1,tzHours); const idx=[2,4,6,8,10,12,14,16,18,20,22,0]; const jeol=idx.map(i=>i===0?tNext[0]:tThis[i]); const brs=["인","묘","진","사","오","미","신","유","술","해","자","축"]; let mIndex=12; for(let i=0;i<jeol.length;i++){ const cur=jeol[i], nxt=jeol[(i+1)%jeol.length]; if(i<jeol.length-1){ if(local>=cur && local<nxt){ mIndex=i+1; break; } } else { const first=jeol[0]; if(local>=cur || local<first){ mIndex=12; } } } const mBranch=brs[(mIndex-1)%12]; const [yStem]=yearPillar(local, tzHours); const map={"갑":"병","기":"병","을":"무","경":"무","병":"경","신":"경","정":"임","임":"임","무":"갑","계":"갑"}; const first=map[yStem]; const mStem=stems[(stems.indexOf(first)+(mIndex-1))%10]; return [mStem, mBranch, jeol]; }
function dayHourPillars(local){ const d=new Date(local.getTime()); if(local.getHours()<23){ d.setDate(d.getDate()-1); } const jd=toJulianDay(d.getFullYear(), d.getMonth()+1, d.getDate()); const jdRef=toJulianDay(1984,2,2); const diff=jd-jdRef; const dStem=stems[(diff%10+10)%10]; const dBranch=branches[(diff%12+12)%12]; const h=local.getHours(); let hBranch; if(h===23) hBranch="자"; else { const mapping=["자","축","인","묘","진","사","오","미","신","유","술","해"]; hBranch=mapping[Math.floor(((h+1)%24)/2)]; } const hbIdx=["자","축","인","묘","진","사","오","미","신","유","술","해"].indexOf(hBranch); const hStem=stems[((stems.indexOf(dStem)%5)*2+hbIdx)%10]; return [dStem,dBranch,hStem,hBranch]; }
function fiveCounts([yG,yZ],[mG,mZ],[dG,dZ],[hG,hZ]){ const c={"목":0,"화":0,"토":0,"금":0,"수":0}; [[yG,yZ],[mG,mZ],[dG,dZ],[hG,hZ]].forEach(([g,z])=>{ c[stemElem[g]]++; c[branchElem[z]]++; }); return c; }
function monthlyPillarsForYear(year, tzHours){ const terms=solarTermsLocal(year,tzHours); const next0=solarTermsLocal(year+1,tzHours)[0]; const idx=[2,4,6,8,10,12,14,16,18,20,22,0]; const times=idx.map(i=>i===0?next0:terms[i]); const labels=["寅","卯","辰","巳","午","未","申","酉","戌","亥","子","丑"]; const [yStem]=yearPillar(new Date(terms[2].getTime()+1), tzHours); const map={"갑":"병","기":"병","을":"무","경":"무","병":"경","신":"경","정":"임","임":"임","무":"갑","계":"갑"}; const first=map[yStem]; const list=[]; for(let i=0;i<12;i++){ const mStem=stems[(stems.indexOf(first)+i)%10]; const mBranch=labels[i]; const start=times[i]; const end=times[(i+1)%12]; list.push({index:i+1, gz:mStem+mBranch, start, end, elem:[stemElem[mStem], branchElem[mBranch]]}); } return list; }
const weights={"목":-1,"화":2,"토":-1,"금":2,"수":2};
function scoreForMonth(mStem,mBranch){ return (weights[stemElem[mStem]]||0)+(weights[branchElem[mBranch]]||0); }
function scoreForYear(year, tzHours){ return monthlyPillarsForYear(year, tzHours).reduce((s,m)=>s+scoreForMonth(m.gz[0],m.gz[1]),0); }
function drawBarChart(canvas, labels, values){ const ctx=canvas.getContext('2d'); const w=canvas.width, h=canvas.height; ctx.clearRect(0,0,w,h); const padding=40; const maxVal=Math.max(...values,1); const minVal=Math.min(...values,0); const yMax=Math.ceil(maxVal/5)*5; const yMin=Math.floor(minVal/5)*5; const yRange=yMax-yMin||10; const plotW=w-padding*2; const plotH=h-padding*2; ctx.beginPath(); ctx.moveTo(padding,padding); ctx.lineTo(padding,h-padding); ctx.lineTo(w-padding,h-padding); ctx.stroke(); const n=values.length; const barW=plotW/(n*1.5); for(let i=0;i<n;i++){ const x=padding+i*(plotW/n)+(plotW/n-barW)/2; const val=values[i]; const y=h-padding-((val-yMin)/yRange)*plotH; const y0=h-padding; ctx.fillRect(x,y,barW,y0-y); ctx.fillText(labels[i], x, h-padding+14); ctx.fillText(String(val), x, y-4); } }
function fmtGZ(g,z){ return `${g}${z} (${stemElem[g]}/${branchElem[z]})`; }
function run(){ const bd=document.getElementById('birthdate').value; const bt=document.getElementById('birthtime').value; const tzHours=parseInt(document.getElementById('tz').value,10); let startYear=parseInt(document.getElementById('startYear').value,10); if(!startYear||startYear<1900){ startYear=new Date().getFullYear(); document.getElementById('startYear').value=startYear; } if(!bd||!bt){ alert('생년월일/시각을 입력하세요.'); return; } const [Y,M,D]=bd.split('-').map(Number); const [h,m]=bt.split(':').map(Number); const dtUTC=new Date(Date.UTC(Y,M-1,D,h - tzHours,m,0)); const local=new Date(dtUTC.getTime()+tzHours*3600*1000); const YP=yearPillar(local,tzHours); const MP=monthPillar(local,tzHours); const [dG,dZ,hG,hZ]=(function(){ const a=dayHourPillars(local); return [a[0],a[1],a[2],a[3]]; })(); const counts=fiveCounts(YP,[MP[0],MP[1]],[dG,dZ],[hG,hZ]); document.getElementById('Y').textContent=fmtGZ(YP[0],YP[1]); document.getElementById('M').textContent=fmtGZ(MP[0],MP[1]); document.getElementById('D').textContent=fmtGZ(dG,dZ); document.getElementById('H').textContent=fmtGZ(hG,hZ); document.getElementById('eMok').textContent=`목: ${counts["목"]}`; document.getElementById('eHwa').textContent=`화: ${counts["화"]}`; document.getElementById('eTo').textContent=`토: ${counts["토"]}`; document.getElementById('eGeum').textContent=`금: ${counts["금"]}`; document.getElementById('eSu').textContent=`수: ${counts["수"]}`; const labels=[], values=[]; for(let y=startYear; y<startYear+10; y++){ labels.push(String(y)); values.push(scoreForYear(y,tzHours)); } drawBarChart(document.getElementById('chart'), labels, values); const tbody=document.querySelector('#yearly tbody'); tbody.innerHTML=''; for(let i=0;i<labels.length;i++){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${labels[i]}</td><td>${values[i]}</td>`; tbody.appendChild(tr); } document.getElementById('result').style.display='block'; }
document.getElementById('btnCalc').addEventListener('click', run);
window.addEventListener('DOMContentLoaded', ()=>{ const now=new Date().getFullYear(); document.getElementById('startYear').value=now; run(); });
